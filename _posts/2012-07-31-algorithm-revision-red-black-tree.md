---
layout: post
title: "Algorithm Revision: Red Black Tree"
description: ""
tags: [algorithme, learning notes]
---

## 2-3-4 树 ##

要说红黑树(RBT), 就要从2-3-4树说起. 234树是一种绝对平衡的查找树, 每个叶子节点到根的距离是相同的(深度). 他的节点分为三种:

 + __2节点__: 有两个孩子的节点, 和BST中的相同
 + __3节点__: 有三个孩子的节点, 同时节点中有两个值, 从小到大排列. 其左子树含有的是小于节点左值的元素, 右子树含有大于节点右值的元素
 + __4节点__: 和3节点类似, 但是有四个孩子, 节点中有三个值. 中间的两个子树分别含有大小介于节点左值和中值, 介于中值和右值的元素

234树长得像这个样子(图片借用Segewick爷爷的):

![](/images/2012-08/RB-234tree-1.png)

### 查找和插入 ###

在234树上的查找和BST相同, 只不过在每个节点中可能要查看多个元素.
插入操作先查找需要插入的值, 如果该值不存在, 那么在叶子节点处插入. 当插入的节点是2节点或3节点的时候, 我们可以直接将新值插入, 使该节点变成3节点或4节点. 但是如果被插入的节点已经是4节点, 就需要预先分割节点.

![](/images/2012-08/RB-234tree-2.png)

根据上层节点的不同(是2节点还是3节点), 分割的方法也分为两种. 分割之后即可简单的插入新值.

### 性能和不足 ###

234树的高度始终是`\(O(lg(n))\)`的, 所以能够保证其上的各种操作都是`\(lg\)`时间的.
但是234树的实现比较复杂, 特别是每个节点的结构不同而且在插入操作的时候需要进行节点转换. 在建立234树的时候分割节点的操作也很频繁. 所以Segewick爷爷就发明了红黑树, 一种用BST结构来实现的234树.

## 红黑树 ##

如果我们把234树的3节点和4节点拆开, 均用二节点来表示:

![](/images/2012-08/RB-234tree-3.png)

特别的, 我们给每一个链接加上一个新的属性: 颜色, 并且把拆成的几个2节点用红色的链接连起来, 如上图. 其他的链接均为黑色的. 这样我们就把一个234树用BST树的的结构表示出来了(因为3节点有两种拆法, 所以234树和红黑树不是一一对应的):

![](/images/2012-08/RB-234tree-4.png)

红黑树形式化的定义如下:

 1. 每个链接不是红色的就是黑色的
 2. 不存在两条连续的红色链接
 3. 连接叶子节点(nil)的链接是黑色的
 4. 从根节点到任意一个叶子节点的简单路径上包含黑色链接的数目相同(这个数目称为黑高度black-height)

也有的版本把颜色属性定义在节点中, 比如CLRS中的红黑树定义:

 1. 每个节点不是红色的就是黑色的
 2. 根节点是黑色的
 3. 每个叶子节点(nil)是黑色的
 4. 如果一个节点是红色的, 则他两个儿子都是黑色的(没有两个连续的红色节点)
 5. 对每个节点, 从该节点到其子孙节点的所有路径上包含相同数目的黑色节点

当然这两种定义方式是相同的, 在实现里都是在节点结构中加入color属性(通常是bool), 对第一种方式的定义而言, 节点中的颜色代表该节点和其父亲节点的链接颜色(inconming link). 不过鉴于红黑树是Segewick爷爷共同发明的, 这里还是按他老人家的定义吧.

### 高度 ###

一个有n个元素的红黑树, 有n+1个叶子节点(每加入一个节点, 它占用一个叶子的位置, 但是增加了2个新的叶子位置, 可以用数归法证明). 设红黑树高度为`\(h\)`, 其对应的234树高度为`\(h'\)`, 那么有

`\[
\sharp\text{RBT leaves}=\sharp\text{234 tree leaves}=\sharp\text{leaves}=n+1 \\
2^{h'} \leq \sharp\text{leaves} \leq 4^{h'} \\
h' \leq lg(n+1) \\
h \leq 2h' \\
\text{所以有  } h \leq 2lg(n+1) = O(lg(n)) \\
\]`

所以红黑树是平衡的查找树.

### 插入操作 ###

和BST一样, 插入和删除操作需要保持红黑树性质.
首先要提到的是旋转操作, 这是一种能保持二叉查找树性质的局部操作, 复杂度为`\(O(1)\)`.

![](/images/2012-08/RB-234tree-5.png)

红黑树插入操作的主要思想就是首先使用BST的插入操作, 将一个节点从底部插入. 然后设置这个节点的链接为红色(如果设为黑色, 则改变的路径上的黑高度, 使得问题更复杂). 然后我们在这个节点上调用一个修改函数使得红黑性质得以保持. 插入操作中, 被破坏的性质一般是性质2, 即不能有两个连续的红链接.
在CLRS的版本中, 这个函数要处理6种情况, 除开左右儿子对称的话, 则是三种不同的情形(p167). 简单来说, 情况1通过修改链接的颜色, 使得破坏红黑性质的链接的位置上升(上升2层). 通过不断的循环情形1, 使得到达树的某一个位置, 我们可以用旋转操作来解决问题.

传统红黑树的插入操作是比较麻烦的, 所以Segewick爷爷又提出了一种简化版的红黑树: 左倾红黑树(left-leaning red-black tree, LLRB). LLRB规定除了传统红黑树的性质以外, 红色的链接只能是父亲和左儿子之间的链接. 换句话说, 这也相当于在把234树的3节点拆成3个红黑节点的时候只有一种拆法:

![](/images/2012-08/RB-234tree-6.png)

这样产生的红黑树和234树就是一一对应了, 简化了其代码实现和算法论证的难度.

### 删除 ###

参考[一][1]

   [1]: http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf
