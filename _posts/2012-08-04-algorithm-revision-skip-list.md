---
layout: post
title: "Algorithm Revision: Skip List"
description: ""
tags: [algorithm, learning notes]
---

平衡查找树能够让我们在对数时间内管理一个动态数据集, 但是其实现相对比较复杂. 给一小时时间, 不看任何资料, 恐怕很难实现其中任何一种. 上课的时候老师曾经用一个练习课讲了skip list, 当时觉得很无厘头, 这个有啥用. 这次看MIT的课, 才发现skip list也是一种能够在对数时间内(几乎)管理动态数据集的数据结构, 而且实现起来非常方便.

## 结构 ##

一般链表结构存储数据的话, 即便是已排序的, 查询操作也需要`\(\Theta(n)\)`的时间. 这是因为链表不具有随机存取的特性(random access), 无法使用二分查找. 而skip list的则是利用多个链表, 跳跃式的存储数据, 来达到加速的目的.

![](/images/2012-08/Skip-list-1.png)

可以把集合中的元素看成是公交车站, 含有全部元素的底部列表就是慢车的线路, 它每站都停. 而上层的链表, 则是快车的线路, 它只停靠某些站点. 元素的查找操作就可以看作是从终点站开始的一次出行, 比如对于上图的skip list, 我们要去66站, 那么可以先坐快车到42, 然后转慢车到66.

## 查找 ##

一般化的skip list查找算法是从最上层的链表开始, 经过一系列比较, 往下达到底层要找的元素. 我们假设链表有两层`\(L_1, L_2\)`, 而且第二层的元素均分了原始的链表, 那么查找过程在底层链表最多走`\(\frac{|L_{1}|}{|L_{2}|}\)`步. 第一层有n个元素, 那么显然总的查找过程要经过的节点个数是`\(|L_{2}|+\frac{n}{|L_{2}|}\)`. 这个式子在`\(|L_{2}|=\frac{n}{|L_{2}|}\)`时取得最小值, 即`\(L_2 = \sqrt{n}\)`. 最佳的两层skip list如下图, 每次查询要走`\(2\sqrt{n}\)`个节点

![](/images/2012-08/Skip-list-2.png)

推广到k层的skip list, 则每次查询要走`\(k\sqrt[k]{n}\)`个节点. 那么怎么确定k的值呢? 首先我们希望查找操作是对数的, 和BBST的一样, 我们又发现k元素是单独在外面的因子, 自然的我们猜测`\(k=lg(n)\)`, 那么原式变成

`\[lg(n)*n^{\frac{1}{lg(n)}}\]`

这个式子看起来... 有点复杂, 但是其实它就是`\(2lg(n)\)`! 你看, __对数时间__!

这个形状的skip list是理想的, 因为当我们插入或者删除节点的时候, 这个形状就会被破坏. 当然, 平均来看, 我们仍旧有非常大的概率在对数时间里完成查找.

## 插入和删除 ##

## 分析 ##


参考[一][1], [二][2]

  [1]: http://stackoverflow.com/questions/256511/skip-list-vs-binary-tree
  [2]: http://www.csee.umbc.edu/courses/undergraduate/341/fall01/Lectures/SkipLists/skip_lists/skip_lists.html
