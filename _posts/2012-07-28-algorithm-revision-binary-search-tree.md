---
layout: post
title: "Algorithm Revision: Binary Search Tree"
description: "算法复习小记, 二叉查找树"
tags: [algorithm, learning notes]
---

## 二叉查找树 ##

二叉查找树(BST)是一个比较简单数据结构. 它能够允许方便的插入操作和查找操作, 其复杂度均取决于树的高度. 二叉查找树是一颗二叉树(当然...), 特征在于任何一个节点的值不小于其左儿子, 不大于其右儿子.  对BST做一个中序遍历得到的序列是已排序的.

### 基本操作 ###

插入, 查找和寻找最大最小元素的操作没有什么可以多说的, 他们的复杂度都是`\(O(h)\)`, h为树的高度. 唯一有一点麻烦的是删除节点的操作, 需要在删除之后保留数据结构的性质. 假定我们有指向需要删除的节点z的指针, 删除操作有以下几个情形:

  + __如果z没有儿子__ 直接修改其父节点, 删除z(使得指向z的指针为NULL)
  + __z只有一个儿子__ 在其父节点和唯一的子节点直接建立一个链接(父节点直接指向孙节点), 之后删除z
  + __z有两个儿子__ 这是最麻烦的情况, 需要找到z的后继元素来替代z. 这种情况下z的后继是z的右子树的最小元素, 可以证明这个元素没有左儿子. 所谓替代就是删除z的后继, 把z后继的值拷贝到z当中来, 完成删除

### 分析 ###

由于二叉查找树的性能和其高度紧密相关, 所以一般我们希望构造出的查找树是`平衡`的. 平衡的定义有很多种, 比较宽泛的说就是查找树的高度`\(h=O(lg(n))\)`. 如果一颗BST是不平衡的, 比如把一个已经排序的序列构造成BST, 那么其相当于一个线性链表. 所以BST有许多变体, 比如红黑树, 伸展树等等. 其思想就是加强BST的定义, 使得构造出的查找树是平衡的.

另外一种思路就是随机化. 在建立BST之前, 我们对输入序列随机排列, 以期望获得一个较好的平均性能(和快排一致). 可以证明随机化建立的查找树有`\(O(lg(n))\)`的期望高度, 证明大致的步骤如下:

 1. 证明[Jensen's inequality][1], 即`\(f(E[X]) \leq E[f(X)]\)`, f为凸函数(convex)
 2. 设`\(X_n\)`是有n个元素的BST的高度, 另设`\(Yn=2^{X_n}\)`
 3. 证明`\(E[Y_n]=O(n^3)\)`
 4. 使用(1), 可得 `\(2^{E(X_n)} \leq E[2^{X_n}] = E[Y_n] = O(n^3)\)`
 5. 上式两边取对数就有 `\(E(X_n)=lgO(n^3)=3lg(n)+O(1)=O(lg(n))\)` 得证.

具体详细过程参考CLRS.

### 快速排序和BST ###

假设我们使用BST来排序, 即先构建BST, 然后中序遍历输出排序结果. 那么这种BST排序最坏情况是`\(O(n^2)\)`, 平均情况(随机构造)下是`\(O(lg(n))\)`. 这和快速排序的情形是十分相似的. 其实BST排序和快速排序做的元素之间的比较次数是相同的, 只是顺序不同. 如果都使用随机化技术, BST排序和快速排序是一模一样的!

仔细想想, 构建BST的时候, 首先我们取输入序列的第一个元素作为根节点(注意序列是随机的一个排列, 所以等价于随机选择一个元素), 然后其他所有的元素都需要和这个根节点比较, 从而进入这个根节点的左子树或者是右子树. 在快排里, 我们需要随机的选取一个pivot, 然后将这个pivot和所有其他元素进行比较将数组一分为二, 这两个子数组是和BST根节点的左右子树等价的. 接下来, 每一个比根元素小的元素又需要和根元素的左儿子(左子树的根)进行比较, 同样的在快速排序中这一步便是递归的应用快速排序到pivot左侧的子数组. 这两种算法的相似性从侧面说明了随机构造的二叉查找树的高度是`\(O(lg(n))\)`.

  [1]: http://en.wikipedia.org/wiki/Jensen's_inequality
