---
layout: post
title: "Link list Cycle Detection"
description: ""
tags: [algorithm, interview]
---

今天看到一道面试题, 考的是如何发现一个单链表中的循环链接. 也就是说一个链表的某一段形成了一个环型结构, 永远也走不出来. 题目还要求如果被检测的链表有循环的话, 要找出这个环状结构最初始的那个节点.

## 朴素的解法 ##
我首先想到的方法是, 对于每一个节点`\(X\)`, 从其开始往后遍历链表, 如果遍历过程中回到这个节点, 则该链表有问题, 如果链表正常结束(遇到null), 则链表不含有循环. 而且在发现循环问题的时候, 节点x便是环状结构最开始的那个节点. 这个解法的正确性毋庸置疑, 但是近似于暴力法, 时间复杂度为`\(O(n^2)\)`.

## 牛逼的解法 ##
有朴素的解法, 那么自然有牛逼的解法. 我们假设`\(X_i\)`是链表中的节点, `\(i \geq 0\)`.

> 使用一快一慢两个指针, 同时从链表首部出发. 慢指针每次走一个节点, 快指针每次走2个节点. 如果当慢指针没有正常走完链表时, 快指针和慢指针相遇了, 那么这个链表含有循环.

这个方法为什么正确呢? 假设循环在位置`\(X_u\)`处开始, 循环体长度为`\(\lambda\)`. 根据循环定义, 当`\(i > u, k > 0\)`的时候, 有`\(X_{i} = X_{i+k\lambda}\)`. 那么当`\(i = k\lambda > u\)`的时候, 有`\(X_{i} = X_{2i}\)`. 这样就证明了, 如果一个链表存在内部循环, 使用快慢指针遍历的时候, 他们是一定会相遇的.

然而在快慢指针第一次相遇的时候呢, 他们的位置可能在循环体中的任何一处. 为了找到循环开始的节点`\(X_u\)`, 我们还需要再遍历一次链表. 可以观察到, 上一个检测循环结束的时候, 两个指针的位置在`\(X_{2i}\)`, 即`\(X_{2k\lambda}\)`. 根据问题的定义, 我们发现`\(X_{u} = X_{2k\lambda + u}\)`是肯定成立的. 那么也就是说, 为了找到`\(X_{u}\)`, 我们只需要让一个指针不动, 另一个指回链表开头`\(X_0\)`, 然后以同样的速度(一次一节点)前进. 当这两个指针第二次相遇的时候, 他们指向的节点就是`\(X_{u}\)`, 即链表内循环的起始节点!

## 小结论 ##
第二个方法在最坏情况下, 需要遍历链表两次, 维护两个指针, 所以是一个线性时间, 常量空间的好算法. 通过这个小例子, 可以看出在解决问题的时候, 不妨对问题进行良好的建模(比如定义`\(u, i, \lambda\)`等), 然后从其特性着手(这里便是链表中的循环`\(X_{i} = X_{i+k\lambda}\)`). 通常这样的方法够带来问题的最优解.

