---
layout: post
title: "Algorithm Revision: Sorting"
description: "算法复习小记, 排序部分"
tags: [algorithm, learning notes]
---

## 排序 ##

排序问题(sorting)是理论计算机研究当中最基本也是研究最为深入的一个部分. 下面几个有趣的事实体现了排序在信息科学里的重要性:

 + 超过25%的cpu时间花在了排序上
 + 各种各样的应用里需要用到排序, 哪怕只是打开手机上的联系人名单
 + 排序是很多其他算法的前置条件, 比如二分搜索(binary search)
 + 研究排序的过程中提出的很多算法设计方法被更广泛的应用到了其他领域, 比如分治法(divide-conquer-combine)

### 排序算法的模型 ###

排序的方法有很多, 有些需要`\(O(n^2)\)`时间(插入排序, 冒泡排序), 有些能够在`\(O(nlgn)\)`时间内完成n个元素的排序(快排的平均情况, 合并排序和堆排序), 而另外一些算法能够在线性时间内完成(计数排序, 桶排序等). 这些算法的复杂度的区别来源于算法本身的模型. 一种常见的排序模型是基于比较的排序, 插入排序, 快速排序等等均属于这个范畴. 在这些排序的结果当中, 各个元素的次序是基于对输入元素之间的比较来决定的.

### 比较排序, 决策树 ###

抽象的来看, 比较排序可以被视为一个决策树(decision tree). 决策树是一个颗满二叉树(complete binary tree), 其每个内部节点含有输入序列中的两个不同元素, 每个外部节点(叶子)则是输入序列的一个排列. 所以一颗决策树有`\(n!\)`个叶子节点. 下面是一个三个元素的输入序列的决策树:

                  1:2
                /     \
             < /     > \
              /         \
           2:3           1:3
           / \           / \
        < / > \       < / > \
         /     \       /     \
     (1,2,3)   1:3  (2,1,3)  2:3
               / \           / \
            < / > \       < / > \
             /     \       /     \
        (1,3,2) (3,1,2)(2,3,1) (3,2,1)

比较排序算法的每次执行即等同于遍历一次其对应的决策树从根到叶子的一条路径. 每个内部节点对应一次比较, 比较的结果决定遍历的走向(左子树还是右子树). 最终达到的叶子节点就是排序的结果.

决策树模型能够帮助我们分析比较排序的最坏情况下届. 我们忽略算法当中的控制结构, 数据移动等等操作, 只把比较次数看作时间消耗的单元. 那么显而易见的是, 决策树的高度就是最坏情况下, 一个比较排序算法需要做的比较次数. 前面提到, n个元素的序列产生的决策树有`\(n!\)`个叶子, 假设树高度h, 则有

`\[n! \leq 2^h\]`

两边取对数, 得

`\[h \geq lg(n!)\]`

根据[斯特林近似公式][1]对n阶乘的展开, 可以得到h的一个下界是`\(\Omega(nlgn)\)`. 可以看出快速排序在一般情况下, 堆排序和合并排序在最坏情况下都是最优的比较排序算法.

### 线性时间排序 ###

在一般的情况下, 普遍适用的算法都是基于比较排序模型的, 所以无法突破`\(\Omega(nlgn)\)`这个下界. 但是如果对输入数据做一定的假设, 我们可以有不依赖于比较模型的算法. 比如说当待排序数字的最大值k和其数量n接近时(准确的说是`\(k=O(n)\)`), 可以使用计数排序(counting sort). 当待排序的数字可以被视作均匀分布在某一区间上时, 可以使用桶排序(bucket sort). 这两个排序算法都不依赖于元素之间的比较, 所以能达到`\(\Omega(n)\)`的下界.


### 排序算法实例 ###


[这里][2]是一些我自己用C实现的排序算法, [这里][3]有比较齐全的排序算法实现. 以前记得有一个较完整的经典算法和数据结构的实现, 是一个斯坦福教授自己的项目, 但是现在找不到了, 找到了补上.

   [1]: http://en.wikipedia.org/wiki/Stirling%27s_approximation
   [2]: https://github.com/darkjh/Algorithm
   [3]: http://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting
